# `for` statement and user types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1885)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
    -   [Other languages](#other-languages)
        -   [C++](#c)
        -   [Python](#python)
        -   [Rust](#rust)
        -   [Typescript](#typescript)
        -   [Go](#go)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Consumable](#consumable)
        -   [Range-based `for` behavior](#range-based-for-behavior)
        -   [Interface and usage](#interface-and-usage)
        -   [TODO](#todo)
    -   [Iterable](#iterable)
        -   [Range-based `for` behavior](#range-based-for-behavior-1)
        -   [Interface and usage](#interface-and-usage-1)
        -   [Iterator: `begin()` & `end()`](#iterator-begin--end)
        -   [Mutable, Bidirectional, and others](#mutable-bidirectional-and-others)
        -   [Chaining & Lazy evaluation](#chaining--lazy-evaluation)
    -   [Limitations and future language improvements](#limitations-and-future-language-improvements)
    -   [TODO](#todo-1)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Indexable](#indexable)
    -   [Using interface type parameters](#using-interface-type-parameters)
    -   [Other](#other)

<!-- tocstop -->

## Abstract

The goal of this proposal is to provide a way for user-defined types to support
range-based iteration with `for`. The proposed solution exposes 2 interfaces
that can be implemented by user types to enable support for ranged-`for` loops.

## Problem

The current `for` proposal does not define a way for user-defined types to
support range-based for loops. Adding support would make it significantly easier
to define custom containers, as well as containers in Carbon standard library.

The goals for the solution includes:

-   Expressive and easy to implement
-   Minimal assumptions and requirements on the user-defined type
-   Minimal impact to maintain and use the type after (loose coupling, minimal
    impact on interface, type content, ...)
-   As well as the standard: Easy to use right, hard to use incorrectly,
    performance, don't pay for what you don't want, ...

While keeping in mind for the future:

-   Compatible with future algorithms (`sort`, `filter`, `transform`, ...)
-   Suitable for chaining (`std::ranges::views`)
-   Suitable for lazy evaluation / generators

## Background

The original proposal of `for` loops were discussed in
[p0353](/proposals/p0353.md), and the basic design documented in
[control_flow/loops#for](/docs/design/control_flow/loops.md#for).

The resulting syntax is:

> `for (` _var declaration_ `in` _expression_ `) {` _statements_ `}`

The original `for` proposal does not define a way for user-defined types to
opt-in to support range-based for loops. An approach is proposed in this
document.

### Other languages

This section highlights some examples of how iterators and range-based for
user-defined types is addressed in different languages.

#### C++

C++ requires us to use the very rich
[`iterator`](https://en.cppreference.com/w/cpp/iterator) library with
`[c]begin()` and `[c]end()`, to support range-based for.

#### Python

Python requires 2 dunder methods, `__iter__` on the container and `__next__` on
the iterator, to be usable with a `for element in container:` construct.

#### Rust

Rust supports iterating over a container with
[for](https://doc.rust-lang.org/rust-by-example/flow_control/for.html) using

-   ranges `for n in 1..100`
-   iterators `for element in container.iter()` or `.iter_mut()`

The `Iterator` type can be used with custom types using the
[following syntax](https://doc.rust-lang.org/rust-by-example/trait/iter.html)
(though specific):

```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        // calculate and yield value
        [...]
    }
}

for i in fibonacci().take(4) {
    ...
}
```

#### Typescript

Typescript uses the
[`.iterator` property](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#iterables),
along with
[two forms](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#forof-statements)
of range-based for loops: `for..in` and `for..of`.

```ts
let pets = new Set(['Cat', 'Dog', 'Hamster']);
pets['species'] = 'mammals';
for (let pet in pets) {
    console.log(pet); // "species"
}
for (let pet of pets) {
    console.log(pet); // "Cat", "Dog", "Hamster"
}
```

Using the `.iterator` property, Typescript allow to lazily generate data easily
using functions, classes, or objects:

```ts
const reverse = (arr) => ({
    [Symbol.iterator]() {
        let i = arr.length;
        return {
            next: () => ({
                value: arr[--i],
                done: i < 0,
            }),
        };
    },
});
```

#### Go

Go has non-standard support for range-based with custom types only.

https://stackoverflow.com/questions/35810674/in-go-is-it-possible-to-iterate-over-a-custom-type

## Proposal

Provide interfaces that can be implemented by user types to enable support for
ranged-for loops.

We propose two interfaces:

-   [**Iterable**](#iterable): An iterator-based sequential access
-   [**Consumable**](#consumable): A single-use sequential access

## Details

This proposal covers support for 2 different type of interfaces:

-   `Iterable`, `Iterator`: An iterator-based sequential access
-   `Consumable`: A single-use sequential access

Due to the semantic and functional difference between these interfaces, they
should not conflict with the
["one way" principle](/docs/project/principles/one_way.md).

When compatible, having multiple interfaces implies for users:

-   A. explicitly support multiple interfaces: expressive, and specialize
    implementations based on type features (likely preferred), or
-   B. define adapters or implicit conversions to respectively simplify
    algorithms implementation or end-user usage

### Consumable

An interface representing single-use sequential access type of container. Items
can be read (consumed) once, and are not expected to be accessible anymore after
usage.

**Note:** This interface makes use of `Optional` type, and assumes its future
definition. The usage highlighted here is hypothetical.

#### Range-based `for` behavior

-   For each iteration, call `Consume() -> Optional(ElementType)`
-   If the `Optional` is null, break the loop. Otherwise return the value held
    by the Optional.

#### Interface and usage

```carbon
// Carbon definition
interface Consumable {
    let ElementType:! Type
    fn Consume[me: Self]() -> Optional(ElementType);
}

// Usage
class MyContainer {
    ...
    impl as Consumable where .ElementType = i32 {
        fn Consume[me: Self]() -> Optional(ElementType) {
            ...
        }
    }
}

var container: MyContainer = {...};
for (var a: auto in container) {}
// `container` is now empty
```

#### TODO

-   Size method?

### Iterable

The `Iterable` interface represents a generic sequential-access type of
container. It relies on two new interfaces:

-   `Iteratable`: Interface for a type that can return an iterator and be
    iterated over
-   `Iterator`: Interface for an iterator-like object

**Note:** This interface makes use of `Optional` type, and assumes its future
definition. The usage highlighted here is hypothetical.

#### Range-based `for` behavior

-   Get an iterator with `GetIterator()`
-   For each iteration, call `Next() -> Optional(ElementType)` on the iterator
    -   If the `Optional` is null, break the loop. Otherwise return the value
        held by the Optional.

#### Interface and usage

```carbon
// Basic immutable iterator
interface Iterator {
    let ElementType:! Type;
    fn Next[me: Self]() -> Optional(ElementType);
}

// Iterable type
interface Iterable {
    let IteratorType:! Iterator;
    fn GetIterator[me: Self]() -> IteratorType;
}
```

These interfaces can be used as such:

```carbon
class MyContainer() {
    ...
    external impl as Iterable {
        class IteratorType { // Associated type as member type
            impl as Iterator where .ElementType = i32 {
                ...

                fn Next[addr me: *Self]() -> Optional(ElementType) {
                    ...
                    return if atEnd then .Empty else currItem;
                }
            }
        }
        fn GetIterator[me: Self]() -> IteratorType {
            return IteratorType { ... }
        }
    }
}
```

#### Iterator: `begin()` & `end()`

The solution highlighted embeds the end condition in `Next()`, returns a null
`Optional` at the last elements. This guarantees that `Iterator`s cannot be used
improperly (code safety goal), and exposes a simple interface, but does have a
performance cost (cost of the `Optional`).

If we want to retain familiarity with C++ iterators and eliminate this cost, one
option would be to expose `Begin()` and `End()` members functions for
`Iterable`, and allow unsafe access. The lack of pointer arithmetic might hinder
performance improvements for unsafe use, but other solutions may exist.

#### Mutable, Bidirectional, and others

The current `Iterator` interfaces allows simple extension to add features such
as bidirectional access (adding `Prev()` method), or mutable access
(`GetMutable[addr me: Self*]() -> ElementType*`, or `Set()`)

#### Chaining & Lazy evaluation

A custom class extending `Iterator` can easily be implemented to be chained with
another `Iterator` directly from the `Next()` method.

```carbon
fn Next[addr me: *Self]() -> Optional(ElementType) {
    while (!atEnd) {
        var item: auto = me->sourceIt->Next();
        if (condition) {
            return item;
        }
    }
    return .Empty
}
```

The same can be used to lazily generate or return values, and allows infinite
generators as well.

### Limitations and future language improvements

The design of this proposal would benefit from future support for:

-   `Optional` (required)
-   attributes
-   `yield`

### TODO

-   Investigate function-level support
-   Using
    [Constraints](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/overview.md#constraints)
    to expose composite Iteratable types.
-   Using
    [Conditional conformance](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/terminology.md#conditional-conformance)
    for mutable, other.
-   Maybe
    [Adapting types](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#adapting-types)
    for flexibility, ad-hoc support for iterating.

    ```carbon
    adapter IterableContainer for Container {
    impl as Iterable { fn Print[me: Self]() { ... } }
    }
    ```

## Rationale

This proposal focuses on user-defined types, which require a great amount of
flexibility with regards to how the final solution is going to be implemented.

In the context, `interface`s represent a non-intrusive, expressive and flexible
solution
([Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)).

It makes use of
[Library APIs only](/docs/project/principles/library_apis_only.md), and is open
to future
[Software and language evolution](/docs/project/goals.md#software-and-language-evolution).

## Alternatives considered

### Indexable

`Indexable` would have represented a container that supports index-based random
access.

However, the definition of an `Indexable` type and its interface would represent
a significant effort in itself, and closely relates to the (currently open)
[Subscript syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/1356)
proposal. An adapter interface for Indexable types might be possible in the
future to support range-based for loop.

### Using interface type parameters

Interfaces can use
[type parameter](/docs/design/generics/terminology.md#interface-type-parameters-and-associated-types)
as `interface Iterator(ItemType:! Type)` instead of associated types. This would
however be inconvenient as they require specifying the type again to be used.

### Other

-   New keyword or syntax
    -   Does not seem needed given the current language features (with
        `Optional`), and
        [Library APIs only](/docs/project/principles/library_apis_only.md)
        preferred.
