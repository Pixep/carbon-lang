# `for` statement and user types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1885)

<!-- toc -->

## Table of contents

-   [Problem](#problem)
-   [Background](#background)
    -   [Other languages](#other-languages)
        -   [Python](#python)
        -   [C++](#c)
        -   [Rust](#rust)
        -   [Typescript](#typescript)
        -   [Go](#go)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Indexable](#indexable)
    -   [Consumable](#consumable)
    -   [Iterable](#iterable)
    -   [TODO / Look into](#todo--look-into)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Using interface type parameters](#using-interface-type-parameters)
    -   [Other](#other)

<!-- tocstop -->

## Problem

Range-based for loops are prevalent in any modern programming language. The
intent is to specify the requirements and conditions and user-defined types to
enable range-based iteration with `for`.

Requirements for this includes:

-   Minimal requirements on the user-defined type
    -   No class requirement?
-   Minimal impact to maintain and use the type after (loose coupling, minimal
    impact on interface, type content, ...)
-   And the standard: Easy to use right, hard to use incorrectly, low effort to
    implement, good performance, don't pay for what you don't want, ...

While keeping in mind for the future:

-   Suitable for chaining (`std::ranges::views`)
-   Suitable for lazy evaluation / generators

## Background

The original proposal of `for` loops were discussed in
[p0353](/proposals/p0353.md), and the basic design documented in
[control_flow/loops#for](/docs/design/control_flow/loops.md#for).

The resulting syntax is:

> `for (` _var declaration_ `in` _expression_ `) {` _statements_ `}`

The original `for` proposal does not define a way for user-defined types to
opt-in to support range-based for loops. An approach is proposed in this
document.

### Other languages

This section highlights some examples of how iterators and range-based for
user-defined types is addressed in different languages.

#### Python

Python requires 2 dunder methods, `__iter__` on the container and `__next__` on
the iterator, to be usable with a `for element in container:` construct.

#### C++

C++ requires us to use the very rich
[`iterator`](https://en.cppreference.com/w/cpp/iterator) library with
`[c]begin()` and `[c]end()`, to support range-based for.

#### Rust

Rust can iterate over data with
[for](https://doc.rust-lang.org/rust-by-example/flow_control/for.html) using

-   ranges `for n in 1..100`
-   iterators `for element in container.iter()` or `.iter_mut()`

The `Iterator` type can be used with custom types using the
[following syntax](https://doc.rust-lang.org/rust-by-example/trait/iter.html)
(though specific):

```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        // calculate and yield value
        [...]
    }
}

for i in fibonacci().take(4) {
    ...
}
```

#### Typescript

Typescript uses the
[`.iterator` property](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#iterables),
along with
[two forms](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#forof-statements)
of range-based for loops: `for..in` and `for..of`.

```ts
let pets = new Set(['Cat', 'Dog', 'Hamster']);
pets['species'] = 'mammals';
for (let pet in pets) {
    console.log(pet); // "species"
}
for (let pet of pets) {
    console.log(pet); // "Cat", "Dog", "Hamster"
}
```

Using the `.iterator` property, Typescript allow to lazily generate data easily
using functions, classes, or objects:

```ts
const reverse = (arr) => ({
    [Symbol.iterator]() {
        let i = arr.length;
        return {
            next: () => ({
                value: arr[--i],
                done: i < 0,
            }),
        };
    },
});
```

#### Go

Go has non-standard support for range-based with custom types only.

https://stackoverflow.com/questions/35810674/in-go-is-it-possible-to-iterate-over-a-custom-type

## Proposal

Provide interfaces that can be implemented by user types to enable support for
ranged-for loops.

There are currently three proposed interfaces:

-   **Indexable**: Random access support to a type using brackets `[]`
-   **Iterable**: A generic iterator-based container
-   **Consumable**: Semantic container for single-use values, remove once read

Due to the semantic and functional difference between these interfaces, they
should not conflict with the [One way](/docs/project/principles/one_way.md).

## Details

### Indexable

This interface is essentially operator overloading for index-based `[]` access.

```rust
interface Indexable() {
    let ElementType:! Type
    fn GetSize[me: Self]() -> u32;
    fn GetAt[me: Self](pos: u32) -> ElementType;
}

class MyContainer {
    impl as Indexable with .ElementType = i32 {
        fn GetSize[me: Self]() -> u32 { ... };
        fn GetAt[me: Self](pos: u32) -> ElementType { ... };
    }
}

for (var a: auto in myContainer) {}
// Or
var a: auto = myContainer[2];
```

TODO:

-   Does an interface already exist for that?
-   Mutable interface?
-   Automatically expose []?

### Consumable

Semantically represent interface containing single-use items once, not
accessible anymore after usage.

```rust
interface Consumable() {
    let ElementType:! Type
    fn Consume[me: Self]() -> Optional(ElementType);
}

class MyContainer {
    impl as Consumable with .ElementType = i32 {
        fn Consume[me: Self]() -> Optional(ElementType);
    }
}

for (var a: auto in myContainer) {}
// `myContainer` is empty
```

TODO:

-   Size, Constraints
-   'Thread'-safety
-   Is that a weird name?

### Iterable

Full power of iterators for mutable, non-mutable, forward, reverse,
view-based/chainable, and lazy:

-   `Iteratable`: Interface for a type that can return an iterator and be
    iterated over
-   `Iterator`: Interface for an iterator-like object

```rust
// Basic immutable iterator
interface Iterator() {
    let ElementType:! Type;
    fn next[me: Self]() -> Optional(ElementType);
}

// Immutable iterable type
interface Iterable() {
    let IteratorType:! Iterator;
    fn GetIterator[me: Self]() -> IteratorType;
}

class MyContainer() {
    var items: [ElementType;10]
    class MyIterator {
        impl as Iterator where .ElementType = i32 {
            var items: [ElementType;10]
            var index: i32 = 0;
            fn next[addr me: Self*]() -> Optional(ElementType) {
                index = index + 1;
                return if index < 10 then items[index] else .Empty
            }
        }
    }
    external impl as Iterable where .IteratorType = MyContainer.MyIterator {
        fn GetIterator[me: Self]() -> IteratorType {
            // Very basic deep copy of container
            var it: IteratorType = {me.items}
        }
    }
}
```

TODO:

-   This feels like a lot just to support iterators
    -   Maybe provide default Iterators(w/slices)?
-   Reverse, Bidirectionnal, ...
-   Mutable, immutable

### TODO / Look into

Recommend external impl to limit type namespace pollution.

Using
[Constraints](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/overview.md#constraints)
to expose composite Iteratable types.

Using
[Conditional conformance](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/terminology.md#conditional-conformance)
for mutable, other.

Maybe
[Adapting types](https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/generics/details.md#adapting-types)
for flexibility, ad-hoc support for iterating.

```
adapter IterableContainer for Container {
  impl as Iterable { fn Print[me: Self]() { ... } }
}
```

## Rationale

Range-based for loop support for user-defined types relates to:

-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)

The solution highlighted relates to:

-   [Library APIs only](/docs/project/principles/library_apis_only.md)
-   [Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)
-   [Software and language evolution](/docs/project/goals.md#software-and-language-evolution)
-   [One way](/docs/project/principles/one_way.md)
    -   Well... not yet really.

## Alternatives considered

### Using interface type parameters

Interfaces can use
[type parameter](/docs/design/generics/terminology.md#interface-type-parameters-and-associated-types)
as `interface Iterator(ItemType:! Type` instead of associated types. This would
however be inconvenient as they require specifying the type again to be used.

### Other

-   New keyword or syntax:
    -   Countered by
        [Library APIs only](/docs/project/principles/library_apis_only.md)
-   Carbon-native implementation instead of interfaces:
    -   ???
