# `for` statement and user types

<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

[Pull request](https://github.com/carbon-language/carbon-lang/pull/1885)

<!-- toc -->

## Table of contents

-   [Abstract](#abstract)
-   [Problem](#problem)
-   [Background](#background)
    -   [Other languages](#other-languages)
        -   [C++](#c)
        -   [Python](#python)
        -   [Rust](#rust)
        -   [Typescript](#typescript)
        -   [Go](#go)
-   [Proposal](#proposal)
-   [Details](#details)
    -   [Iterable](#iterable)
        -   [Range-based `for` behavior](#range-based-for-behavior)
        -   [Interface and usage](#interface-and-usage)
        -   [Chaining & Lazy evaluation](#chaining--lazy-evaluation)
        -   [Support for other use cases](#support-for-other-use-cases)
    -   [Other interfaces](#other-interfaces)
        -   [Compatibility](#compatibility)
        -   [Possible interface for 'Consumable' containers](#possible-interface-for-consumable-containers)
            -   [Range-based `for` behavior](#range-based-for-behavior-1)
            -   [Interface and usage](#interface-and-usage-1)
    -   [Limitations and future language improvements](#limitations-and-future-language-improvements)
-   [Rationale](#rationale)
-   [Alternatives considered](#alternatives-considered)
    -   [Indexable](#indexable)
    -   [Using interface type parameters](#using-interface-type-parameters)
    -   [Relying only on `Next()` from `Iterator` to move and get value](#relying-only-on-next-from-iterator-to-move-and-get-value)
    -   [Iterator's `begin()` & `end()` methods](#iterators-begin--end-methods)
    -   [Returning `Optional(T)` instead of `T` for getters](#returning-optionalt-instead-of-t-for-getters)
    -   [Other](#other)

<!-- tocstop -->

## Abstract

This proposes an interface that can be implemented by user types to support
range-based iteration with `for`.

## Problem

The current `for` proposal does not define a way for user-defined types to
support range-based for loops. Adding support would make it significantly easier
to define custom containers, as well as containers in Carbon standard library.

Example of data and use cases include:

-   Iterating over mutable and immutable data
-   Iterating over an r-value container
-   Random access containers (array)
-   Forward and reverse iteration
-   Iterating over maps, hash maps, and complex containers
-   Iterating through synthetic data

The goals for the solution includes:

-   Expressive and easy to implement
-   Minimal assumptions and requirements on the user-defined type
-   Minimal impact to maintain and use the type after (loose coupling, minimal
    impact on interface, type content, ...)
-   Minimal performance impact
-   As well as the standard: Easy to use right, hard to use incorrectly

While keeping in mind for the future:

-   Compatible with future algorithms (`sort`, `filter`, `transform`, ...)
-   Suitable for chaining (`std::ranges::views`)
-   Suitable for lazy evaluation / generators

## Background

The original proposal of `for` loops were discussed in
[p0353](/proposals/p0353.md), and the basic design documented in
[control_flow/loops#for](/docs/design/control_flow/loops.md#for).

The resulting syntax is:

> `for (` _var declaration_ `in` _expression_ `) {` _statements_ `}`

The original `for` proposal does not define a way for user-defined types to
opt-in to support range-based for loops. An approach is proposed in this
document.

This can be achieved using either a cursor or an iterator. A cursor benefits
from being simple to manipulate and understand, and is used against a container.
On the other hand, an iterators benefits from being more self-contained
(dereferencing, next item, and optionally boundary), at the expense of its
complexity.

### Other languages

This section highlights some examples of how iterators and range-based for
user-defined types is addressed in different languages.

#### C++

C++ requires us to use the very rich
[`iterator`](https://en.cppreference.com/w/cpp/iterator) library with
`[c]begin()` and `[c]end()`, to support range-based for.

#### Python

Python requires 2 dunder methods, `__iter__` on the container and `__next__` on
the iterator, to be usable with a `for element in container:` construct.

#### Rust

Rust supports iterating over a container with
[for](https://doc.rust-lang.org/rust-by-example/flow_control/for.html) using

-   ranges `for n in 1..100`
-   iterators `for element in container.iter()` or `.iter_mut()`

The `Iterator` type can be used with custom types using the
[following syntax](https://doc.rust-lang.org/rust-by-example/trait/iter.html)
(though specific):

```rust
struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        // calculate and yield value
        [...]
    }
}

for i in fibonacci().take(4) {
    ...
}
```

#### Typescript

Typescript uses the
[`.iterator` property](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#iterables),
along with
[two forms](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#forof-statements)
of range-based for loops: `for..in` and `for..of`.

```ts
let pets = new Set(['Cat', 'Dog', 'Hamster']);
pets['species'] = 'mammals';
for (let pet in pets) {
    console.log(pet); // "species"
}
for (let pet of pets) {
    console.log(pet); // "Cat", "Dog", "Hamster"
}
```

Using the `.iterator` property, Typescript allow to lazily generate data easily
using functions, classes, or objects:

```ts
const reverse = (arr) => ({
    [Symbol.iterator]() {
        let i = arr.length;
        return {
            next: () => ({
                value: arr[--i],
                done: i < 0,
            }),
        };
    },
});
```

#### Go

Go has non-standard support for range-based with custom types only.

https://stackoverflow.com/questions/35810674/in-go-is-it-possible-to-iterate-over-a-custom-type

## Proposal

Provide interfaces that can be implemented by user types to enable support for
ranged-for loops.

We propose a new [**Iterable**](#iterable) interface, for iterator-based
sequential access, and usage with range-based `for`.

## Details

This proposal exposes an Iterable-type interface, relying on 2 new interfaces:
`Iterable` and `Iterator`.

A user implements these interfaces to enable range-based `for` support. Carbon
would make use of the `Iterable` to retrieve an `Iterator` and iterate until
completed or interrupted.

### Iterable

The `Iterable` interface represents a generic sequential-access type of
container. It relies on two new interfaces:

-   `Iterable` and `MutableIterable`: Interface for a type that supports being
    iterated over
-   `Iterator`: Interface for an iterator-like object

#### Range-based `for` behavior

-   Get an `Iterator` type with `GetIterator()` or `GetMutableIterator()`
-   Call `Advance() -> bool`
    -   Break the loop if the result is `false`
-   Call `Get()` and return the result

#### Interface and usage

These interfaces are defined as:

```carbon
// Basic immutable iterator
interface Iterator {
    let ElementType:! Type;
    // Return element. Needed in the broader context of
    // Iterators and C++ interop
    fn Get[me: Self]() -> ElementType;
    // Advance our iterator
    fn Advance[me: *Self]() -> bool;
    // Advance and return element
    fn Next[addr me: *Self]() -> ElementType;
}

// Iterable type
interface Iterable {
    let IteratorType:! Iterator;
    fn GetIterator[me: Self]() -> IteratorType;
}
// Mutable iterable type
interface MutableIterable {
    let IteratorType:! Iterator;
    fn GetMutableIterator[me: Self]() -> IteratorType;
}
```

They can be used as illustrated below, for a container that provides both
mutable and immutable iterators:

```carbon
class MyContainer() {
    ...
    class MyIterator(ElementType:! Type) { // Associated type as member type
        impl as Iterator where .ElementType = .Self.ElementType {
            ...
            fn Get[me: Self]() -> ElementType {
                return if atEnd then .Empty else currItem;
            }
            fn Advance[me: *Self]() -> bool {
                // Increment position
                ...

                return if atEnd then false else true;
            }
            fn Next[addr me: *Self]() -> ElementType {
                me->Advance();
                return me->Get();
            }
        }
    }
    external impl as Iterable where .IteratorType = MyIterator(.MyContainer.ElementType) {
        fn GetIterator[me: Self]() -> auto {
            return MyIterator(.MyContainer.ElementType) { ... }
        }
    }
    external impl as MutableIterable where .IteratorType = MyIterator(.MyContainer.ElementType*) {
        fn GetMutableIterator[me: Self]() -> auto {
            return MyIterator(.MyContainer.ElementType*) { ... }
        }
    }
}
```

#### Chaining & Lazy evaluation

A custom class extending `Iterator` can easily be implemented to be chained with
another `Iterator` using `Get()` and `Advance()` methods.

```carbon
fn Get[addr me: *Self]() -> ElementType {
    if atEnd then .Empty else me->sourceIt->item;
}
fn Advance[addr me: *Self]() -> bool {
    while (!me->sourceIt->Advance()) {
        if (condition_met) {
            return true;
        }
    }
    return false
}
```

The same can be used to lazily generate or return values, and allows infinite
generators as well.

#### Support for other use cases

The `Iterator` interface can be extended to add features such

-   bidirectional access: add `Prev()` method
-   supporting specific data access (tuples, hash map, ...): add
    `GetFirst`/`GetTupleValue`, or `GetKey`/`GetValue`

It supports without any modifications:

-   Sets
-   Synthetic data
-   Random access containers, by wrapping the cursor using the `Advance()`
    method

TODO: Temporary data, R-values

### Other interfaces

#### Compatibility

With `Iterable` (and `Iterator`) as the main interface, we can support other
interfaces implicitly. For a (non yet existing) `Indexable` interface for
example, Carbon can provide a corresponding `Iterable` parameterized final
implementation:

```carbon
final impl forall [T:! Indexable] T as Iterable;
```

The same is applicable for users willing to automatically provide `Iterable`
(and `for`) support for a custom interface.

#### Possible interface for 'Consumable' containers

Below is a suggestion for future 'consumable' containers. The `Consumable`
interface would represent a single-use sequential access type of container.
Items can be read (consumed) once, and are not expected to be accessible anymore
after usage.

**Note:** This interface makes use of `Optional` type, and assumes its future
definition. The usage highlighted here is hypothetical.

##### Range-based `for` behavior

-   For each iteration, call `Consume() -> Optional(ElementType)`
-   If the `Optional` is null, break the loop. Otherwise return the value held
    by the Optional.

##### Interface and usage

```carbon
// Carbon definition
interface Consumable {
    let ElementType:! Type
    fn Consume[me: Self]() -> Optional(ElementType);
}

// Usage
class MyContainer {
    ...
    impl as Consumable where .ElementType = i32 {
        fn Consume[me: Self]() -> Optional(ElementType) {
            ...
        }
    }
}

var container: MyContainer = {...};
for (var a: auto in container) {}
// `container` is now empty
```

### Limitations and future language improvements

The design of this proposal would benefit from future support for:

-   attributes
-   `yield`
-   C++ interoperability for iterators

## Rationale

This proposal focuses on user-defined types, which require a great amount of
flexibility with regards to how the final solution is going to be implemented.

In the context, `interface`s represent a non-intrusive, expressive and flexible
solution
([Code that is easy to read, understand, and write](/docs/project/goals.md#code-that-is-easy-to-read-understand-and-write)).

It makes use of
[Library APIs only](/docs/project/principles/library_apis_only.md), and is open
to future
[Software and language evolution](/docs/project/goals.md#software-and-language-evolution).

## Alternatives considered

### Indexable

`Indexable` would have represented a container that supports index-based random
access.

However, the definition of an `Indexable` type and its interface would represent
a significant effort in itself, and closely relates to the (currently open)
[Subscript syntax and semantics](https://github.com/carbon-language/carbon-lang/pull/1356)
proposal. An adapter interface for Indexable types might be possible in the
future to support range-based for loop.

### Using interface type parameters

Interfaces can use
[type parameter](/docs/design/generics/terminology.md#interface-type-parameters-and-associated-types)
as `interface Iterator(ItemType:! Type)` instead of associated types. This would
however be inconvenient as they require specifying the type again to be used.

### Relying only on `Next()` from `Iterator` to move and get value

The `Iterator` interface currently exposes both `Get` and `Next` methods. While
`Next` could be sufficient to support iterating and retrieving data (returned),
this makes the C++ interoperability complex, by not allowing straightforward
dereferencing (C++'s `operator*`) without side-effects.

Exposing a `Get` method allow for a simple mapping of iterator dereferencing,
which is needed to provide proper interoperability.

### Iterator's `begin()` & `end()` methods

C++ makes use of `begin()` and `end()` methods on the containers to return
iterators. Because iterators in C++ don't include boundaries information, users
are force to provide both an end boundary. End boundaries may be unsafe, and are
difficult to check/validate at compile-time.

The alternative proposed here is to allow the iterator to provide boundary check
information using the `Advance() -> bool` methods on the iterator itself. This
offer a more self-contained (no boundary necessary), and safer usage of
Iterators. This has the drawback of changing the way iterators are commonly
used, but retains a logic similar enough, that `Iterator` could be adapted for
C++ interoperability by customizing `Advance()`.

### Returning `Optional(T)` instead of `T` for getters

Using `Optional(T)` for the `Get()` method of iterators would have the main
advantage of preventing any invalid access past the boundaries of the element
set (code safety goal), and intrinsically provides the state of the iteration.
This however has the a some limitations:

-   Wrapping elements add a size overhead to any data, and a potential access
    cost as well
-   Interoperability with C++ containers and iterators would be more complicated
-   Uses a different than C++
-   R-value containers and elements might require to be copied to be wrapped in
    an `Optional(T)`

### Other

-   New keyword or syntax: Not needed given the current language features and as
    [Library APIs only](/docs/project/principles/library_apis_only.md) is
    preferred.
